- 객체지향 프로그래밍에서 핵심은 도메인을 분리한 뒤, 특성과 행위를 정의하며 추상화와 상속으로 부모 및 자식으로 다형성을 구축하는 것이 일반적인 객체지향중심 관점의 프로그래밍으로 인지했으며, 이를 통해 유연한 구축이 가능할 것으로 예상하고 있었으나 **첫 시작부터 나의 생각을 개 박살내버렸다.** 공통적으로 각각의 행위[변하는 부분]가 되는 부분은 인터페이스와 추상 메서드로 분리하고, 행위를 사용하고자 하려는 클래스 내부에 구성(Has A) 구조로 의존성 주입처럼 의존 메서드만 호출하라는 권장을 살펴볼 수 있었다.
- 디자인 패턴은 규약된 확장성 및 재사용성을 위해 각각의 전략을 세운 코드 스타일라고 이해했다. 협업하는 과정에서 구구절절 설명하는 식으로 가는 것 보다, 약속된 패턴 명칭만으로 소통하면서 뭔가 좀 멋있어 보이면서도, 설명하는 시간에 코드 리뷰와 같은 다른 소통에 시간을 더 투자할 수 있으니 말이다. 책에서도 전문용어는 햇병아리 개발자에게 훌륭한 자극제가 된다고 한다. 나도 더 성장하고 있어보이기 위해 지금부터 디자인패턴을 하나씩 음미해야겠다.
- 옵저버 패턴
    - 객체 사이에 일대다의 의존 관계[1의 발행자, N의 구독자]가 있고, 어떤 객체의 상태가 변하게 되면 그 객체에 의존성을 가진 다른 객체들이 변화의 통지를 받고 자동으로 갱신될 수 있게 함
        - Pushish-Subscribe 패턴과 다른점?
            - **Publisher**는 메시지를 보낼 때 **각각의 메시지에 Topic 이름을 부여할 수 있는데, 이때 Subscriber는 이 Topic 이름을 사용하여 원하는 정보만 선택적으로 수신하는 방식 ⇒ 즉, 구독자가 원하는 Topic을 구독하는 형식으로 원한는 관심사의 값들만 선택적으로 받는다.**

![](../../../../../../../var/folders/4w/krkl_gpx1dl5j0rhpkb7nc340000gn/T/TemporaryItems/NSIRD_screencaptureui_gmOpqP/스크린샷 2023-08-24 오후 3.00.32.png)
- **Subject** : Observer를 알고 있는 주체, Observer를 더하거나 뺄수 있음
- **Observer** : Subject의 변화에 관심을 가지는 객체, 갱신에 필요한 인터페이스 정의, 객체들의 일관성을 유지
- **ConcreteSubject** : ConcreteObserver에게 알려주어야하는 상태가 변경될때 통보 (주로 List로 Observer관리)
- **ConcreteObserver** : 객체에 대한 참조자를 관리하고, Subject의 일관성 유지하며, Subject가 변경될 때 갱신되는 인터페이스 구현
- 느슨한 결합 → 객체 사이의 상호 의존성을 최소화 한다. [옵저버가 훌륭한 예시]
    - 객체들이 서로 상호작용은 할 수 있으나, 서로를 잘 모르는 관계를 말함 ⇒ 유연성이 높아짐
    - 유연성 : 계속 변해가는 상황 속에서 요구사항을 충분히 수용할 수 있는 구조
    - 옵저버는 언제든지 새로추가할 수 있다고 하는데, 주제는 옵저버 인터페이스를 구현하는 객체의 목록에만 의존하기 때문에 언제든지 새로 추가할 수 있다. 추가한다고 주제가 바뀔일은 없다.

  ⇒ 느슨한 결합 덕분에 주제나 옵저버를 다른 용도로 사용하려고 코드를 수정하려고 해도 결합도가 낮기에 쉽게 재사용이 가능하다.

- 자바 빈즈 라이브러리도 옵저버 패턴을 사용하고 있다고 한다.
- 자바에서는 Observable이라는 클래스를 제공하여 옵버저 패턴을 개발자가 작성하지 않고 활용이 가능하였으나, 현재 JDK 9버전 이후로는 지원이 중단되었다고 한다.
- Push-Pull 방식을 접목하는 것도 좋은 방법이 될 수 있다고 한다.
    - 기존에는 주제 클래스에서 update해주어 원치않는 상황에서도 최신 값들을 강제로 받아야하는 방식
    - 옵저버가 필요할 떄, PULL하여 데이터를 가져오는 방식이 더 좋을 수 있다고 한다.
        - 주제가 자신의 데이터에 관한 게터 메서드를 가지게하고 옵저버는 그 메서드만 호출하면 됨